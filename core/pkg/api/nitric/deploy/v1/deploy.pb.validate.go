// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: proto/deploy/v1/deploy.proto

package v1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on DeployUpRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *DeployUpRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeployUpRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeployUpRequestMultiError, or nil if none found.
func (m *DeployUpRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeployUpRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetSpec()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeployUpRequestValidationError{
					field:  "Spec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeployUpRequestValidationError{
					field:  "Spec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSpec()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeployUpRequestValidationError{
				field:  "Spec",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Attributes

	if len(errors) > 0 {
		return DeployUpRequestMultiError(errors)
	}

	return nil
}

// DeployUpRequestMultiError is an error wrapping multiple validation errors
// returned by DeployUpRequest.ValidateAll() if the designated constraints
// aren't met.
type DeployUpRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeployUpRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeployUpRequestMultiError) AllErrors() []error { return m }

// DeployUpRequestValidationError is the validation error returned by
// DeployUpRequest.Validate if the designated constraints aren't met.
type DeployUpRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeployUpRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeployUpRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeployUpRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeployUpRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeployUpRequestValidationError) ErrorName() string { return "DeployUpRequestValidationError" }

// Error satisfies the builtin error interface
func (e DeployUpRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeployUpRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeployUpRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeployUpRequestValidationError{}

// Validate checks the field values on DeployUpEvent with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DeployUpEvent) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeployUpEvent with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DeployUpEventMultiError, or
// nil if none found.
func (m *DeployUpEvent) ValidateAll() error {
	return m.validate(true)
}

func (m *DeployUpEvent) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch m.Content.(type) {

	case *DeployUpEvent_Message:

		if all {
			switch v := interface{}(m.GetMessage()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DeployUpEventValidationError{
						field:  "Message",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DeployUpEventValidationError{
						field:  "Message",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetMessage()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DeployUpEventValidationError{
					field:  "Message",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *DeployUpEvent_Result:

		if all {
			switch v := interface{}(m.GetResult()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DeployUpEventValidationError{
						field:  "Result",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DeployUpEventValidationError{
						field:  "Result",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetResult()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DeployUpEventValidationError{
					field:  "Result",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return DeployUpEventMultiError(errors)
	}

	return nil
}

// DeployUpEventMultiError is an error wrapping multiple validation errors
// returned by DeployUpEvent.ValidateAll() if the designated constraints
// aren't met.
type DeployUpEventMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeployUpEventMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeployUpEventMultiError) AllErrors() []error { return m }

// DeployUpEventValidationError is the validation error returned by
// DeployUpEvent.Validate if the designated constraints aren't met.
type DeployUpEventValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeployUpEventValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeployUpEventValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeployUpEventValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeployUpEventValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeployUpEventValidationError) ErrorName() string { return "DeployUpEventValidationError" }

// Error satisfies the builtin error interface
func (e DeployUpEventValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeployUpEvent.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeployUpEventValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeployUpEventValidationError{}

// Validate checks the field values on DeployEventMessage with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeployEventMessage) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeployEventMessage with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeployEventMessageMultiError, or nil if none found.
func (m *DeployEventMessage) ValidateAll() error {
	return m.validate(true)
}

func (m *DeployEventMessage) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Message

	if len(errors) > 0 {
		return DeployEventMessageMultiError(errors)
	}

	return nil
}

// DeployEventMessageMultiError is an error wrapping multiple validation errors
// returned by DeployEventMessage.ValidateAll() if the designated constraints
// aren't met.
type DeployEventMessageMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeployEventMessageMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeployEventMessageMultiError) AllErrors() []error { return m }

// DeployEventMessageValidationError is the validation error returned by
// DeployEventMessage.Validate if the designated constraints aren't met.
type DeployEventMessageValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeployEventMessageValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeployEventMessageValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeployEventMessageValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeployEventMessageValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeployEventMessageValidationError) ErrorName() string {
	return "DeployEventMessageValidationError"
}

// Error satisfies the builtin error interface
func (e DeployEventMessageValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeployEventMessage.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeployEventMessageValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeployEventMessageValidationError{}

// Validate checks the field values on UpResult with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *UpResult) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpResult with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in UpResultMultiError, or nil
// if none found.
func (m *UpResult) ValidateAll() error {
	return m.validate(true)
}

func (m *UpResult) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch m.Content.(type) {

	case *UpResult_StringResult:
		// no validation rules for StringResult

	}

	if len(errors) > 0 {
		return UpResultMultiError(errors)
	}

	return nil
}

// UpResultMultiError is an error wrapping multiple validation errors returned
// by UpResult.ValidateAll() if the designated constraints aren't met.
type UpResultMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpResultMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpResultMultiError) AllErrors() []error { return m }

// UpResultValidationError is the validation error returned by
// UpResult.Validate if the designated constraints aren't met.
type UpResultValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpResultValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpResultValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpResultValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpResultValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpResultValidationError) ErrorName() string { return "UpResultValidationError" }

// Error satisfies the builtin error interface
func (e UpResultValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpResult.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpResultValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpResultValidationError{}

// Validate checks the field values on DeployUpEventResult with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeployUpEventResult) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeployUpEventResult with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeployUpEventResultMultiError, or nil if none found.
func (m *DeployUpEventResult) ValidateAll() error {
	return m.validate(true)
}

func (m *DeployUpEventResult) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Success

	if all {
		switch v := interface{}(m.GetResult()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeployUpEventResultValidationError{
					field:  "Result",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeployUpEventResultValidationError{
					field:  "Result",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetResult()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeployUpEventResultValidationError{
				field:  "Result",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DeployUpEventResultMultiError(errors)
	}

	return nil
}

// DeployUpEventResultMultiError is an error wrapping multiple validation
// errors returned by DeployUpEventResult.ValidateAll() if the designated
// constraints aren't met.
type DeployUpEventResultMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeployUpEventResultMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeployUpEventResultMultiError) AllErrors() []error { return m }

// DeployUpEventResultValidationError is the validation error returned by
// DeployUpEventResult.Validate if the designated constraints aren't met.
type DeployUpEventResultValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeployUpEventResultValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeployUpEventResultValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeployUpEventResultValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeployUpEventResultValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeployUpEventResultValidationError) ErrorName() string {
	return "DeployUpEventResultValidationError"
}

// Error satisfies the builtin error interface
func (e DeployUpEventResultValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeployUpEventResult.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeployUpEventResultValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeployUpEventResultValidationError{}

// Validate checks the field values on DeployDownRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *DeployDownRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeployDownRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeployDownRequestMultiError, or nil if none found.
func (m *DeployDownRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeployDownRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Attributes

	if len(errors) > 0 {
		return DeployDownRequestMultiError(errors)
	}

	return nil
}

// DeployDownRequestMultiError is an error wrapping multiple validation errors
// returned by DeployDownRequest.ValidateAll() if the designated constraints
// aren't met.
type DeployDownRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeployDownRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeployDownRequestMultiError) AllErrors() []error { return m }

// DeployDownRequestValidationError is the validation error returned by
// DeployDownRequest.Validate if the designated constraints aren't met.
type DeployDownRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeployDownRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeployDownRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeployDownRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeployDownRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeployDownRequestValidationError) ErrorName() string {
	return "DeployDownRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeployDownRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeployDownRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeployDownRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeployDownRequestValidationError{}

// Validate checks the field values on DeployDownEvent with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *DeployDownEvent) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeployDownEvent with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeployDownEventMultiError, or nil if none found.
func (m *DeployDownEvent) ValidateAll() error {
	return m.validate(true)
}

func (m *DeployDownEvent) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch m.Content.(type) {

	case *DeployDownEvent_Message:

		if all {
			switch v := interface{}(m.GetMessage()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DeployDownEventValidationError{
						field:  "Message",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DeployDownEventValidationError{
						field:  "Message",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetMessage()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DeployDownEventValidationError{
					field:  "Message",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *DeployDownEvent_Result:

		if all {
			switch v := interface{}(m.GetResult()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DeployDownEventValidationError{
						field:  "Result",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DeployDownEventValidationError{
						field:  "Result",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetResult()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DeployDownEventValidationError{
					field:  "Result",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return DeployDownEventMultiError(errors)
	}

	return nil
}

// DeployDownEventMultiError is an error wrapping multiple validation errors
// returned by DeployDownEvent.ValidateAll() if the designated constraints
// aren't met.
type DeployDownEventMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeployDownEventMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeployDownEventMultiError) AllErrors() []error { return m }

// DeployDownEventValidationError is the validation error returned by
// DeployDownEvent.Validate if the designated constraints aren't met.
type DeployDownEventValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeployDownEventValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeployDownEventValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeployDownEventValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeployDownEventValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeployDownEventValidationError) ErrorName() string { return "DeployDownEventValidationError" }

// Error satisfies the builtin error interface
func (e DeployDownEventValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeployDownEvent.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeployDownEventValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeployDownEventValidationError{}

// Validate checks the field values on DeployDownEventResult with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeployDownEventResult) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeployDownEventResult with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeployDownEventResultMultiError, or nil if none found.
func (m *DeployDownEventResult) ValidateAll() error {
	return m.validate(true)
}

func (m *DeployDownEventResult) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return DeployDownEventResultMultiError(errors)
	}

	return nil
}

// DeployDownEventResultMultiError is an error wrapping multiple validation
// errors returned by DeployDownEventResult.ValidateAll() if the designated
// constraints aren't met.
type DeployDownEventResultMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeployDownEventResultMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeployDownEventResultMultiError) AllErrors() []error { return m }

// DeployDownEventResultValidationError is the validation error returned by
// DeployDownEventResult.Validate if the designated constraints aren't met.
type DeployDownEventResultValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeployDownEventResultValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeployDownEventResultValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeployDownEventResultValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeployDownEventResultValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeployDownEventResultValidationError) ErrorName() string {
	return "DeployDownEventResultValidationError"
}

// Error satisfies the builtin error interface
func (e DeployDownEventResultValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeployDownEventResult.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeployDownEventResultValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeployDownEventResultValidationError{}

// Validate checks the field values on ImageSource with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ImageSource) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ImageSource with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ImageSourceMultiError, or
// nil if none found.
func (m *ImageSource) ValidateAll() error {
	return m.validate(true)
}

func (m *ImageSource) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Uri

	if len(errors) > 0 {
		return ImageSourceMultiError(errors)
	}

	return nil
}

// ImageSourceMultiError is an error wrapping multiple validation errors
// returned by ImageSource.ValidateAll() if the designated constraints aren't met.
type ImageSourceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ImageSourceMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ImageSourceMultiError) AllErrors() []error { return m }

// ImageSourceValidationError is the validation error returned by
// ImageSource.Validate if the designated constraints aren't met.
type ImageSourceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ImageSourceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ImageSourceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ImageSourceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ImageSourceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ImageSourceValidationError) ErrorName() string { return "ImageSourceValidationError" }

// Error satisfies the builtin error interface
func (e ImageSourceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sImageSource.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ImageSourceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ImageSourceValidationError{}

// Validate checks the field values on ExecutionUnit with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ExecutionUnit) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExecutionUnit with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ExecutionUnitMultiError, or
// nil if none found.
func (m *ExecutionUnit) ValidateAll() error {
	return m.validate(true)
}

func (m *ExecutionUnit) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Workers

	// no validation rules for Timeout

	// no validation rules for Memory

	switch m.Source.(type) {

	case *ExecutionUnit_Image:

		if all {
			switch v := interface{}(m.GetImage()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ExecutionUnitValidationError{
						field:  "Image",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ExecutionUnitValidationError{
						field:  "Image",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetImage()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ExecutionUnitValidationError{
					field:  "Image",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ExecutionUnitMultiError(errors)
	}

	return nil
}

// ExecutionUnitMultiError is an error wrapping multiple validation errors
// returned by ExecutionUnit.ValidateAll() if the designated constraints
// aren't met.
type ExecutionUnitMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExecutionUnitMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExecutionUnitMultiError) AllErrors() []error { return m }

// ExecutionUnitValidationError is the validation error returned by
// ExecutionUnit.Validate if the designated constraints aren't met.
type ExecutionUnitValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExecutionUnitValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExecutionUnitValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExecutionUnitValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExecutionUnitValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExecutionUnitValidationError) ErrorName() string { return "ExecutionUnitValidationError" }

// Error satisfies the builtin error interface
func (e ExecutionUnitValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExecutionUnit.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExecutionUnitValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExecutionUnitValidationError{}

// Validate checks the field values on Bucket with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Bucket) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Bucket with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in BucketMultiError, or nil if none found.
func (m *Bucket) ValidateAll() error {
	return m.validate(true)
}

func (m *Bucket) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return BucketMultiError(errors)
	}

	return nil
}

// BucketMultiError is an error wrapping multiple validation errors returned by
// Bucket.ValidateAll() if the designated constraints aren't met.
type BucketMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BucketMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BucketMultiError) AllErrors() []error { return m }

// BucketValidationError is the validation error returned by Bucket.Validate if
// the designated constraints aren't met.
type BucketValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BucketValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BucketValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BucketValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BucketValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BucketValidationError) ErrorName() string { return "BucketValidationError" }

// Error satisfies the builtin error interface
func (e BucketValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBucket.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BucketValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BucketValidationError{}

// Validate checks the field values on Topic with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Topic) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Topic with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in TopicMultiError, or nil if none found.
func (m *Topic) ValidateAll() error {
	return m.validate(true)
}

func (m *Topic) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetSubscriptions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TopicValidationError{
						field:  fmt.Sprintf("Subscriptions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TopicValidationError{
						field:  fmt.Sprintf("Subscriptions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TopicValidationError{
					field:  fmt.Sprintf("Subscriptions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return TopicMultiError(errors)
	}

	return nil
}

// TopicMultiError is an error wrapping multiple validation errors returned by
// Topic.ValidateAll() if the designated constraints aren't met.
type TopicMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TopicMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TopicMultiError) AllErrors() []error { return m }

// TopicValidationError is the validation error returned by Topic.Validate if
// the designated constraints aren't met.
type TopicValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TopicValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TopicValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TopicValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TopicValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TopicValidationError) ErrorName() string { return "TopicValidationError" }

// Error satisfies the builtin error interface
func (e TopicValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTopic.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TopicValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TopicValidationError{}

// Validate checks the field values on Queue with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Queue) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Queue with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in QueueMultiError, or nil if none found.
func (m *Queue) ValidateAll() error {
	return m.validate(true)
}

func (m *Queue) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return QueueMultiError(errors)
	}

	return nil
}

// QueueMultiError is an error wrapping multiple validation errors returned by
// Queue.ValidateAll() if the designated constraints aren't met.
type QueueMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m QueueMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m QueueMultiError) AllErrors() []error { return m }

// QueueValidationError is the validation error returned by Queue.Validate if
// the designated constraints aren't met.
type QueueValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e QueueValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e QueueValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e QueueValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e QueueValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e QueueValidationError) ErrorName() string { return "QueueValidationError" }

// Error satisfies the builtin error interface
func (e QueueValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sQueue.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = QueueValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = QueueValidationError{}

// Validate checks the field values on Collection with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Collection) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Collection with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CollectionMultiError, or
// nil if none found.
func (m *Collection) ValidateAll() error {
	return m.validate(true)
}

func (m *Collection) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return CollectionMultiError(errors)
	}

	return nil
}

// CollectionMultiError is an error wrapping multiple validation errors
// returned by Collection.ValidateAll() if the designated constraints aren't met.
type CollectionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CollectionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CollectionMultiError) AllErrors() []error { return m }

// CollectionValidationError is the validation error returned by
// Collection.Validate if the designated constraints aren't met.
type CollectionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CollectionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CollectionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CollectionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CollectionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CollectionValidationError) ErrorName() string { return "CollectionValidationError" }

// Error satisfies the builtin error interface
func (e CollectionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCollection.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CollectionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CollectionValidationError{}

// Validate checks the field values on Secret with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Secret) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Secret with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in SecretMultiError, or nil if none found.
func (m *Secret) ValidateAll() error {
	return m.validate(true)
}

func (m *Secret) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return SecretMultiError(errors)
	}

	return nil
}

// SecretMultiError is an error wrapping multiple validation errors returned by
// Secret.ValidateAll() if the designated constraints aren't met.
type SecretMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SecretMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SecretMultiError) AllErrors() []error { return m }

// SecretValidationError is the validation error returned by Secret.Validate if
// the designated constraints aren't met.
type SecretValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SecretValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SecretValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SecretValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SecretValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SecretValidationError) ErrorName() string { return "SecretValidationError" }

// Error satisfies the builtin error interface
func (e SecretValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSecret.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SecretValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SecretValidationError{}

// Validate checks the field values on SubscriptionTarget with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SubscriptionTarget) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SubscriptionTarget with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SubscriptionTargetMultiError, or nil if none found.
func (m *SubscriptionTarget) ValidateAll() error {
	return m.validate(true)
}

func (m *SubscriptionTarget) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch m.Target.(type) {

	case *SubscriptionTarget_ExecutionUnit:
		// no validation rules for ExecutionUnit

	}

	if len(errors) > 0 {
		return SubscriptionTargetMultiError(errors)
	}

	return nil
}

// SubscriptionTargetMultiError is an error wrapping multiple validation errors
// returned by SubscriptionTarget.ValidateAll() if the designated constraints
// aren't met.
type SubscriptionTargetMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SubscriptionTargetMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SubscriptionTargetMultiError) AllErrors() []error { return m }

// SubscriptionTargetValidationError is the validation error returned by
// SubscriptionTarget.Validate if the designated constraints aren't met.
type SubscriptionTargetValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SubscriptionTargetValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SubscriptionTargetValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SubscriptionTargetValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SubscriptionTargetValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SubscriptionTargetValidationError) ErrorName() string {
	return "SubscriptionTargetValidationError"
}

// Error satisfies the builtin error interface
func (e SubscriptionTargetValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSubscriptionTarget.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SubscriptionTargetValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SubscriptionTargetValidationError{}

// Validate checks the field values on TopicSubscription with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *TopicSubscription) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TopicSubscription with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TopicSubscriptionMultiError, or nil if none found.
func (m *TopicSubscription) ValidateAll() error {
	return m.validate(true)
}

func (m *TopicSubscription) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTarget()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TopicSubscriptionValidationError{
					field:  "Target",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TopicSubscriptionValidationError{
					field:  "Target",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTarget()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TopicSubscriptionValidationError{
				field:  "Target",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return TopicSubscriptionMultiError(errors)
	}

	return nil
}

// TopicSubscriptionMultiError is an error wrapping multiple validation errors
// returned by TopicSubscription.ValidateAll() if the designated constraints
// aren't met.
type TopicSubscriptionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TopicSubscriptionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TopicSubscriptionMultiError) AllErrors() []error { return m }

// TopicSubscriptionValidationError is the validation error returned by
// TopicSubscription.Validate if the designated constraints aren't met.
type TopicSubscriptionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TopicSubscriptionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TopicSubscriptionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TopicSubscriptionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TopicSubscriptionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TopicSubscriptionValidationError) ErrorName() string {
	return "TopicSubscriptionValidationError"
}

// Error satisfies the builtin error interface
func (e TopicSubscriptionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTopicSubscription.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TopicSubscriptionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TopicSubscriptionValidationError{}

// Validate checks the field values on Api with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Api) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Api with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in ApiMultiError, or nil if none found.
func (m *Api) ValidateAll() error {
	return m.validate(true)
}

func (m *Api) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch m.Document.(type) {

	case *Api_Openapi:
		// no validation rules for Openapi

	}

	if len(errors) > 0 {
		return ApiMultiError(errors)
	}

	return nil
}

// ApiMultiError is an error wrapping multiple validation errors returned by
// Api.ValidateAll() if the designated constraints aren't met.
type ApiMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ApiMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ApiMultiError) AllErrors() []error { return m }

// ApiValidationError is the validation error returned by Api.Validate if the
// designated constraints aren't met.
type ApiValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ApiValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ApiValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ApiValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ApiValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ApiValidationError) ErrorName() string { return "ApiValidationError" }

// Error satisfies the builtin error interface
func (e ApiValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sApi.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ApiValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ApiValidationError{}

// Validate checks the field values on ScheduleTarget with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ScheduleTarget) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ScheduleTarget with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ScheduleTargetMultiError,
// or nil if none found.
func (m *ScheduleTarget) ValidateAll() error {
	return m.validate(true)
}

func (m *ScheduleTarget) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch m.Target.(type) {

	case *ScheduleTarget_ExecutionUnit:
		// no validation rules for ExecutionUnit

	}

	if len(errors) > 0 {
		return ScheduleTargetMultiError(errors)
	}

	return nil
}

// ScheduleTargetMultiError is an error wrapping multiple validation errors
// returned by ScheduleTarget.ValidateAll() if the designated constraints
// aren't met.
type ScheduleTargetMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ScheduleTargetMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ScheduleTargetMultiError) AllErrors() []error { return m }

// ScheduleTargetValidationError is the validation error returned by
// ScheduleTarget.Validate if the designated constraints aren't met.
type ScheduleTargetValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ScheduleTargetValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ScheduleTargetValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ScheduleTargetValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ScheduleTargetValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ScheduleTargetValidationError) ErrorName() string { return "ScheduleTargetValidationError" }

// Error satisfies the builtin error interface
func (e ScheduleTargetValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sScheduleTarget.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ScheduleTargetValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ScheduleTargetValidationError{}

// Validate checks the field values on Schedule with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Schedule) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Schedule with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ScheduleMultiError, or nil
// if none found.
func (m *Schedule) ValidateAll() error {
	return m.validate(true)
}

func (m *Schedule) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Cron

	if all {
		switch v := interface{}(m.GetTarget()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ScheduleValidationError{
					field:  "Target",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ScheduleValidationError{
					field:  "Target",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTarget()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ScheduleValidationError{
				field:  "Target",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ScheduleMultiError(errors)
	}

	return nil
}

// ScheduleMultiError is an error wrapping multiple validation errors returned
// by Schedule.ValidateAll() if the designated constraints aren't met.
type ScheduleMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ScheduleMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ScheduleMultiError) AllErrors() []error { return m }

// ScheduleValidationError is the validation error returned by
// Schedule.Validate if the designated constraints aren't met.
type ScheduleValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ScheduleValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ScheduleValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ScheduleValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ScheduleValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ScheduleValidationError) ErrorName() string { return "ScheduleValidationError" }

// Error satisfies the builtin error interface
func (e ScheduleValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSchedule.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ScheduleValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ScheduleValidationError{}

// Validate checks the field values on Resource with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Resource) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Resource with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ResourceMultiError, or nil
// if none found.
func (m *Resource) ValidateAll() error {
	return m.validate(true)
}

func (m *Resource) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Type

	switch m.Config.(type) {

	case *Resource_ExecutionUnit:

		if all {
			switch v := interface{}(m.GetExecutionUnit()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ResourceValidationError{
						field:  "ExecutionUnit",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ResourceValidationError{
						field:  "ExecutionUnit",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetExecutionUnit()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ResourceValidationError{
					field:  "ExecutionUnit",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Resource_Bucket:

		if all {
			switch v := interface{}(m.GetBucket()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ResourceValidationError{
						field:  "Bucket",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ResourceValidationError{
						field:  "Bucket",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetBucket()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ResourceValidationError{
					field:  "Bucket",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Resource_Topic:

		if all {
			switch v := interface{}(m.GetTopic()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ResourceValidationError{
						field:  "Topic",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ResourceValidationError{
						field:  "Topic",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetTopic()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ResourceValidationError{
					field:  "Topic",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Resource_Queue:

		if all {
			switch v := interface{}(m.GetQueue()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ResourceValidationError{
						field:  "Queue",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ResourceValidationError{
						field:  "Queue",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetQueue()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ResourceValidationError{
					field:  "Queue",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Resource_Api:

		if all {
			switch v := interface{}(m.GetApi()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ResourceValidationError{
						field:  "Api",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ResourceValidationError{
						field:  "Api",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetApi()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ResourceValidationError{
					field:  "Api",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Resource_Policy:

		if all {
			switch v := interface{}(m.GetPolicy()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ResourceValidationError{
						field:  "Policy",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ResourceValidationError{
						field:  "Policy",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetPolicy()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ResourceValidationError{
					field:  "Policy",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Resource_Schedule:

		if all {
			switch v := interface{}(m.GetSchedule()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ResourceValidationError{
						field:  "Schedule",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ResourceValidationError{
						field:  "Schedule",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetSchedule()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ResourceValidationError{
					field:  "Schedule",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Resource_Collection:

		if all {
			switch v := interface{}(m.GetCollection()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ResourceValidationError{
						field:  "Collection",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ResourceValidationError{
						field:  "Collection",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetCollection()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ResourceValidationError{
					field:  "Collection",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Resource_Secret:

		if all {
			switch v := interface{}(m.GetSecret()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ResourceValidationError{
						field:  "Secret",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ResourceValidationError{
						field:  "Secret",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetSecret()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ResourceValidationError{
					field:  "Secret",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ResourceMultiError(errors)
	}

	return nil
}

// ResourceMultiError is an error wrapping multiple validation errors returned
// by Resource.ValidateAll() if the designated constraints aren't met.
type ResourceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ResourceMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ResourceMultiError) AllErrors() []error { return m }

// ResourceValidationError is the validation error returned by
// Resource.Validate if the designated constraints aren't met.
type ResourceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ResourceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ResourceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ResourceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ResourceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ResourceValidationError) ErrorName() string { return "ResourceValidationError" }

// Error satisfies the builtin error interface
func (e ResourceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sResource.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ResourceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ResourceValidationError{}

// Validate checks the field values on Policy with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Policy) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Policy with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in PolicyMultiError, or nil if none found.
func (m *Policy) ValidateAll() error {
	return m.validate(true)
}

func (m *Policy) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetPrincipals() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PolicyValidationError{
						field:  fmt.Sprintf("Principals[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PolicyValidationError{
						field:  fmt.Sprintf("Principals[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PolicyValidationError{
					field:  fmt.Sprintf("Principals[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetResources() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PolicyValidationError{
						field:  fmt.Sprintf("Resources[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PolicyValidationError{
						field:  fmt.Sprintf("Resources[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PolicyValidationError{
					field:  fmt.Sprintf("Resources[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return PolicyMultiError(errors)
	}

	return nil
}

// PolicyMultiError is an error wrapping multiple validation errors returned by
// Policy.ValidateAll() if the designated constraints aren't met.
type PolicyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PolicyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PolicyMultiError) AllErrors() []error { return m }

// PolicyValidationError is the validation error returned by Policy.Validate if
// the designated constraints aren't met.
type PolicyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PolicyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PolicyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PolicyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PolicyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PolicyValidationError) ErrorName() string { return "PolicyValidationError" }

// Error satisfies the builtin error interface
func (e PolicyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPolicy.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PolicyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PolicyValidationError{}

// Validate checks the field values on Spec with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Spec) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Spec with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in SpecMultiError, or nil if none found.
func (m *Spec) ValidateAll() error {
	return m.validate(true)
}

func (m *Spec) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetResources() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SpecValidationError{
						field:  fmt.Sprintf("Resources[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SpecValidationError{
						field:  fmt.Sprintf("Resources[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SpecValidationError{
					field:  fmt.Sprintf("Resources[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return SpecMultiError(errors)
	}

	return nil
}

// SpecMultiError is an error wrapping multiple validation errors returned by
// Spec.ValidateAll() if the designated constraints aren't met.
type SpecMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SpecMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SpecMultiError) AllErrors() []error { return m }

// SpecValidationError is the validation error returned by Spec.Validate if the
// designated constraints aren't met.
type SpecValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SpecValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SpecValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SpecValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SpecValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SpecValidationError) ErrorName() string { return "SpecValidationError" }

// Error satisfies the builtin error interface
func (e SpecValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSpec.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SpecValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SpecValidationError{}
