// Copyright 2021 Nitric Pty Ltd.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package azure_storage_queue_service

import (
	"context"
	"encoding/json"
	"fmt"
	"net/url"
	"time"

	"github.com/nitric-dev/membrane/pkg/utils"
	"github.com/valyala/fasthttp"

	"github.com/Azure/azure-storage-queue-go/azqueue"

	"github.com/nitric-dev/membrane/pkg/plugins/errors"
	"github.com/nitric-dev/membrane/pkg/plugins/errors/codes"
	"github.com/nitric-dev/membrane/pkg/plugins/queue"
)

// Set to 30 seconds,
const defaultVisibilityTimeout = 30 * time.Second

// Default Azure Storage Account Name for Nitric Stack
const azureStorageAccountEnv = "AZURE_STORAGE_ACCOUNT_NAME"

type AzureStorageQueueService struct {
	queue.UnimplementedQueuePlugin
	storageAccountName       string
	storageAccountCredential azqueue.Credential
}

func (s *AzureStorageQueueService) queueURL(queue string) (*url.URL, error) {
	queueUrl, err := url.Parse(fmt.Sprintf("https://%s.queue.core.windows.net/%s", s.storageAccountName, queue))
	if err != nil {
		return nil, fmt.Errorf("failed to construct Azure Storage Queues connection string. %v", err)
	}
	return queueUrl, nil
}

func (s *AzureStorageQueueService) getClients(queue string) (*azqueue.QueueURL, *azqueue.MessagesURL, error) {
	// Construct the queue connection URL
	rawQueueURL, err := s.queueURL(queue)
	if err != nil {
		return nil, nil, err
	}

	// Construct a client to perform operations on the queue
	// the Azure SDK calls this a QueueURL, but the term URL is misleading. It's a client containing a URL.
	queueClient := azqueue.NewQueueURL(*rawQueueURL, azqueue.NewPipeline(s.storageAccountCredential, azqueue.PipelineOptions{}))
	//ctx := context.TODO()

	// Retrieve the queue's properties to ensure it exists.
	//_, err = queueClient.GetProperties(ctx)
	//if err != nil {
	//	// https://godoc.org/github.com/Azure/azure-storage-queue-go/azqueue#StorageErrorCodeType
	//	errorType := err.(azqueue.StorageError).ServiceCode()
	//
	//	if errorType == azqueue.ServiceCodeQueueNotFound {
	//		return nil, nil, newErr(
	//			codes.NotFound,
	//			fmt.Sprintf("queue not found"),
	//			err,
	//		)
	//	} else {
	//		return newErr(
	//			codes.Unknown,
	//			fmt.Sprintf("failed to retrieve queue properties"),
	//			err,
	//		)
	//	}
	//}

	// Construct a client to perform message operations on the queue
	messagesClient := queueClient.NewMessagesURL()
	return &queueClient, &messagesClient, nil
}

func (s *AzureStorageQueueService) Send(queue string, task queue.NitricTask) error {
	newErr := errors.ErrorsWithScope(
		"AzureStorageQueueService.Send",
		fmt.Sprintf("queue=%s", queue),
	)

	_, messagesClient, err := s.getClients(queue)
	if err != nil {
		return newErr(
			codes.FailedPrecondition,
			"failed to establish connection to queue",
			err,
		)
	}

	// Send the tasks to the queue
	if taskBytes, err := json.Marshal(task); err == nil {
		ctx := context.TODO()
		if _, err := messagesClient.Enqueue(ctx, string(taskBytes), 0, 0); err != nil {
			return newErr(
				codes.Internal,
				"error sending task to queue",
				err,
			)
		}
	} else {
		return newErr(
			codes.Internal,
			"error marshalling the task",
			err,
		)
	}

	return nil
}

func (s *AzureStorageQueueService) SendBatch(queueName string, tasks []queue.NitricTask) (*queue.SendBatchResponse, error) {
	failedTasks := make([]*queue.FailedTask, 0)

	for _, task := range tasks {
		// Azure Storage Queues don't support batches, so each task must be sent individually.
		err := s.Send(queueName, task)
		if err != nil {
			failedTasks = append(failedTasks, &queue.FailedTask{
				Task:    &task,
				Message: err.Error(),
			})
		}
	}

	return &queue.SendBatchResponse{
		FailedTasks: failedTasks,
	}, nil
}

// AzureQueueItemLease - Represents a lease of an Azure Storages Queues item
// Azure requires a combination of their unique reference for a queue item (id) and a pop receipt (lease id)
// to perform operations on the item, such as delete it from the queue.
type AzureQueueItemLease struct {
	// The ID of the queue item
	// note: this is an id generated by Azure, it's not the user provided unique id.
	ID string
	// lease id, a new popReceipt is generated each time an item is dequeued.
	PopReceipt string
}

// String - convert the item lease struct to a string, to be returned as a NitricTask LeaseID
func (l *AzureQueueItemLease) String() (string, error) {
	leaseID, err := json.Marshal(l)
	return string(leaseID), err
}

// leaseFromString - Unmarshal a NitricTask Lease ID (JSON) to an AzureQueueItemLease
func leaseFromString(leaseID string) (*AzureQueueItemLease, error) {
	var lease AzureQueueItemLease
	err := json.Unmarshal([]byte(leaseID), &lease)
	if err != nil {
		return nil, err
	}
	return &lease, nil
}

// Receive - Receives a collection of tasks off a given queue.
func (s *AzureStorageQueueService) Receive(options queue.ReceiveOptions) ([]queue.NitricTask, error) {
	newErr := errors.ErrorsWithScope(
		"AzureStorageQueueService.Receive",
		fmt.Sprintf("options=%v", options),
	)

	if err := options.Validate(); err != nil {
		return nil, newErr(
			codes.InvalidArgument,
			"invalid receive options provided",
			err,
		)
	}

	_, messagesClient, err := s.getClients(options.QueueName)
	if err != nil {
		return nil, newErr(
			codes.FailedPrecondition,
			"failed to establish connection to queue",
			err,
		)
	}

	ctx := context.TODO()

	dequeueResp, err := messagesClient.Dequeue(ctx, int32(*options.Depth), defaultVisibilityTimeout)
	if err != nil {
		return nil, newErr(
			codes.Internal,
			"failed to received messages from the queue",
			err,
		)
	}

	if dequeueResp.NumMessages() == 0 {
		return []queue.NitricTask{}, nil
	}

	// Convert the Azure Storage Queues messages into Nitric tasks
	var tasks []queue.NitricTask
	for i := int32(0); i < dequeueResp.NumMessages(); i++ {
		m := dequeueResp.Message(i)
		var nitricTask queue.NitricTask
		err := json.Unmarshal([]byte(m.Text), &nitricTask)
		if err != nil {
			// TODO: append error to error list and Nack the message.
			continue
		}

		lease := AzureQueueItemLease{
			ID:         m.ID.String(),
			PopReceipt: m.PopReceipt.String(),
		}
		leaseID, err := lease.String()
		// This should never happen, it's a fatal error
		if err != nil {
			return nil, newErr(
				codes.Internal,
				"failed to construct queue item lease id",
				err,
			)
		}

		tasks = append(tasks, queue.NitricTask{
			ID:          nitricTask.ID,
			Payload:     nitricTask.Payload,
			PayloadType: nitricTask.PayloadType,
			LeaseID:     leaseID,
		})
	}

	return tasks, nil
}

// Complete - Completes a previously popped queue item
func (s *AzureStorageQueueService) Complete(queue string, leaseId string) error {
	newErr := errors.ErrorsWithScope(
		"AzureStorageQueueService.Complete",
		fmt.Sprintf("queue=%s", queue),
	)

	lease, err := leaseFromString(leaseId)
	if err != nil {
		return newErr(
			codes.InvalidArgument,
			"failed to unmarshal lease id value",
			err,
		)
	}

	_, messagesClient, err := s.getClients(queue)
	if err != nil {
		return newErr(
			codes.FailedPrecondition,
			"failed to establish connection to queue",
			err,
		)
	}

	// Client for the specific message referenced by the lease
	messageClient := messagesClient.NewMessageIDURL(azqueue.MessageID(lease.ID))
	ctx := context.TODO()
	_, err = messageClient.Delete(ctx, azqueue.PopReceipt(lease.PopReceipt))
	if err != nil {
		return newErr(
			codes.Internal,
			"failed to complete task",
			err,
		)
	}

	return nil
}

// ResourceTokenResponse - Represents an Azure resource token response returned from /MSI/token
// See: https://docs.microsoft.com/en-us/azure/app-service/overview-managed-identity?tabs=dotnet#using-the-rest-protocol
type ResourceTokenResponse struct {
	// The requested access token. The calling web service can use this token to authenticate to the receiving web service.
	AccessToken string `json:"access_token"`
	// The client ID of the identity that was used.
	ClientID string `json:"client_id"`
	// The timespan when the access token expires. The date is represented as the number of seconds from "1970-01-01T0:0:0Z UTC" (corresponds to the token's exp claim).
	ExpiresOn time.Time `json:"expires_on"`
	// The timespan when the access token takes effect, and can be accepted. The date is represented as the number of seconds from "1970-01-01T0:0:0Z UTC" (corresponds to the token's nbf claim).
	NotBefore time.Time `json:"not_before"`
	// The resource the access token was requested for, which matches the resource query string parameter of the request.
	Resource string `json:"resource"`
	// Indicates the token type value. The only type that Azure AD supports is Bearer.
	TokenType string `json:"token_type"`
}

// getAuthToken - retrieve a resource access token using the system's managed identity
func getAuthToken(resourceUri string) (*ResourceTokenResponse, error) {
	identityEndpoint := utils.GetEnv("IDENTITY_ENDPOINT", "")
	if identityEndpoint == "" {
		return nil, fmt.Errorf("failed to read IDENTITY_ENDPOINT environment variable")
	}
	identityHeader := utils.GetEnv("IDENTITY_HEADER", "")
	if identityHeader == "" {
		return nil, fmt.Errorf("failed to read IDENTITY_HEADER environment variable")
	}
	tokenAuthUri := fmt.Sprintf("%s?resource=%s&api-version=2019-08-01", identityEndpoint, resourceUri)

	request := fasthttp.AcquireRequest()
	response := fasthttp.AcquireResponse()

	// Release resources after finishing
	defer func() {
		request.Reset()
		response.Reset()
		fasthttp.ReleaseRequest(request)
		fasthttp.ReleaseResponse(response)
	}()

	request.Header.Set("X-IDENTITY-HEADER", identityHeader)
	request.SetRequestURI(tokenAuthUri)

	err := fasthttp.Do(request, response)
	if err != nil {
		return nil, fmt.Errorf("error retrieving system-assigned managed identity token. %v", err)
	}
	if response.StatusCode() != 200 {
		return nil, fmt.Errorf("error retrieving system-assigned managed identity token. status %d returned from token API", response.StatusCode())
	}

	var tokenResponse ResourceTokenResponse

	err = json.Unmarshal(response.Body(), &tokenResponse)
	if err != nil {
		return nil, fmt.Errorf("error retrieving system-assigned managed identity token. %v", err)
	}

	return &tokenResponse, nil
}

//
//// adaptNewClient - Adapts the pubsubbase.NewSubscriberClient func to one that implements the SubscriberClient
//// interface. This is used to enable substitution of the base pubsub client, primarily for mocking support.
//func adaptNewClient(f func(context.Context, ...option.ClientOption) (*pubsubbase.SubscriberClient, error)) func(ctx context.Context, opts ...option.ClientOption) (ifaces_pubsub.SubscriberClient, error) {
//	return func(c context.Context, opts ...option.ClientOption) (ifaces_pubsub.SubscriberClient, error) {
//		return f(c, opts...)
//	}
//}

const storageResourceUri string = "https://storage.azure.com/"

// New - Constructs a new Azure Storage Queues client with defaults
func New() (queue.QueueService, error) {
	// TODO: determine if URI with account name is required, e.g. https://<account>.queue.core.windows.net
	// https://docs.microsoft.com/en-us/azure/active-directory/managed-identities-azure-resources/services-support-managed-identities#azure-storage-blobs-and-queues
	tokenResponse, err := getAuthToken(storageResourceUri)
	if err != nil {
		return nil, err
	}

	// Create the storage account credentials object and refresher callback
	credentials := azqueue.NewTokenCredential(tokenResponse.AccessToken, func(credential azqueue.TokenCredential) time.Duration {
		newTokenResponse, err := getAuthToken(storageResourceUri)
		if err != nil {
			// TODO: log/panic?
			return 0 // stop refreshing
		}
		credential.SetToken(newTokenResponse.AccessToken)
		// Return the time until the token expires, so it can be refreshed
		return newTokenResponse.ExpiresOn.Sub(time.Now())
	})

	storageAccountName := utils.GetEnv(azureStorageAccountEnv, "")
	if storageAccountName == "" {
		return nil, fmt.Errorf("failed to determine Azure Storage Account Name, environment variable %s not set", azureStorageAccountEnv)
	}

	return &AzureStorageQueueService{
		storageAccountCredential: credentials,
		storageAccountName:       storageAccountName,
	}, nil
}

//func NewWithClient(client ifaces_pubsub.PubsubClient) queue.QueueService {
//	return &AzureStorageQueueService{
//		client: client,
//	}
//}
